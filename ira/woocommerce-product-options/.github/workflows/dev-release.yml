name: Update `dev` pre-release and attach ZIP installer

on:
  push:
    tags:
      - 'dev'
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: dev-pre-release
  cancel-in-progress: true

jobs:
  build-and-attach:
    runs-on: ubuntu-latest
    env:
      TAG_NAME: dev
      GH_TOKEN: ${{ github.token }}
    steps:
      - name: Check out repo at the tag
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      - name: Set repo name, ZIP name, and detect changes
        run: |
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          echo "REPO_NAME=${REPO_NAME}" >> "$GITHUB_ENV"
          echo "ZIP_NAME=${REPO_NAME}.zip" >> "$GITHUB_ENV"

          # Find changes (case variants)
          for CANDIDATE in CHANGES.md changes.md Changes.md; do
            if [ -f "$CANDIDATE" ]; then
              echo "NOTES_FILE=${CANDIDATE}" >> "$GITHUB_ENV"
              echo "Using notes from: $CANDIDATE"
              exit 0
            fi
          done
          echo "NOTES_FILE=" >> "$GITHUB_ENV"
          echo "No changes found; will use fallback notes."

      - name: Create ZIP from tag (with repo root prefix)
        run: |
          git archive \
            --format=zip \
            --prefix="${REPO_NAME}/" \
            --output="${ZIP_NAME}" \
            "${TAG_NAME}"
          ls -lh "${ZIP_NAME}"

      - name: Ensure prerelease exists (tag/name = dev) and set notes
        run: |
          set -euo pipefail
          REPO="${GITHUB_REPOSITORY}"
          COMMIT_HASH=$(git rev-parse "${TAG_NAME}")

          NOTES_TMP=$(mktemp)

          if [ -n "${NOTES_FILE:-}" ]; then
            cat "${NOTES_FILE}" > "${NOTES_TMP}"
            echo -e "\n\n---\nTag \`${TAG_NAME}\` commit: \`${COMMIT_HASH}\`" >> "${NOTES_TMP}"
          else
            echo "Automated pre-release for ${TAG_NAME}" > "${NOTES_TMP}"
            echo -e "\n\n---\nTag \`${TAG_NAME}\` commit: \`${COMMIT_HASH}\`" >> "${NOTES_TMP}"
          fi

          if ! gh release view "${TAG_NAME}" --repo "${REPO}" >/dev/null 2>&1; then
            gh release create "${TAG_NAME}" \
              --title "${TAG_NAME}" \
              --notes-file "${NOTES_TMP}" \
              --prerelease \
              --repo "${REPO}"
          else
            gh release edit "${TAG_NAME}" \
              --notes-file "${NOTES_TMP}" \
              --repo "${REPO}"
          fi

      - name: Delete all existing assets from prerelease
        run: |
          REPO="${GITHUB_REPOSITORY}"
          ASSET_IDS=$(gh api "repos/${REPO}/releases/tags/${TAG_NAME}" --jq '.assets[].id' || true)
          for ID in ${ASSET_IDS}; do
            gh api -X DELETE "repos/${REPO}/releases/assets/${ID}"
            echo "Deleted asset id ${ID}"
          done

      - name: Upload ZIP as single asset
        run: |
          REPO="${GITHUB_REPOSITORY}"
          gh release upload "${TAG_NAME}" "${ZIP_NAME}" --repo "${REPO}" --clobber
          echo "Uploaded ${ZIP_NAME} to prerelease '${TAG_NAME}'."
